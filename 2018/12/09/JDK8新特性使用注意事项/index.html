<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="jave8," />










<meta name="description" content="JDK8 新特性 使用注意事项Optional Optional 是基于值的类，所以当涉及到识别敏感的操作（比如引用判等 == ，哈希值比较或者同步）时，使用 Optional 可能有不可预测的结果，所以这些场景下应该避免使用 Optional。 empty() 是一个静态工厂方法，返回一个空的容器。当判断是否存在值的时候不应该将这个 Optional 对象和 Optional.empty() =">
<meta name="keywords" content="jave8">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK8新特性使用注意事项">
<meta property="og:url" content="http://yoursite.com/2018/12/09/JDK8新特性使用注意事项/index.html">
<meta property="og:site_name" content="Zomone">
<meta property="og:description" content="JDK8 新特性 使用注意事项Optional Optional 是基于值的类，所以当涉及到识别敏感的操作（比如引用判等 == ，哈希值比较或者同步）时，使用 Optional 可能有不可预测的结果，所以这些场景下应该避免使用 Optional。 empty() 是一个静态工厂方法，返回一个空的容器。当判断是否存在值的时候不应该将这个 Optional 对象和 Optional.empty() =">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-12-09T04:12:15.120Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JDK8新特性使用注意事项">
<meta name="twitter:description" content="JDK8 新特性 使用注意事项Optional Optional 是基于值的类，所以当涉及到识别敏感的操作（比如引用判等 == ，哈希值比较或者同步）时，使用 Optional 可能有不可预测的结果，所以这些场景下应该避免使用 Optional。 empty() 是一个静态工厂方法，返回一个空的容器。当判断是否存在值的时候不应该将这个 Optional 对象和 Optional.empty() =">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/09/JDK8新特性使用注意事项/"/>





  <title>JDK8新特性使用注意事项 | Zomone</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zomone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Good artists copy, great artists steal.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/09/JDK8新特性使用注意事项/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zomeone">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zomone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JDK8新特性使用注意事项</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T12:07:27+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java-se/" itemprop="url" rel="index">
                    <span itemprop="name">java se</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JDK8-新特性-使用注意事项"><a href="#JDK8-新特性-使用注意事项" class="headerlink" title="JDK8 新特性 使用注意事项"></a>JDK8 新特性 使用注意事项</h1><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ol>
<li>Optional 是基于值的类，所以当涉及到识别敏感的操作（比如引用判等 == ，哈希值比较或者同步）时，使用 Optional 可能有不可预测的结果，所以这些场景下应该避免使用 Optional。</li>
<li>empty() 是一个静态工厂方法，返回一个空的容器。当判断是否存在值的时候不应该将这个 Optional 对象和 <code>Optional.empty() == obj</code> 判等。因为无法确保 <code>empty()</code> 是单例的。判断元素是否为空应该使用 <code>isPresent()</code>。</li>
<li><code>filter()</code> 方法会在满足给定的 <code>Predicate</code> 的情况下返回一个包含该元素的 Optional, 否则返回一个空的 Optional。</li>
<li><code>map</code> 接收的是一个 <code>Function</code></li>
<li><p><code>flapMap</code> 类似于 <code>map</code>,但是，从说明文档可以看出，<code>map</code> 基于，而 <code>flatMap</code> 基于一个已经是 <code>Optional</code> 的参数进行计算，当被调用时，<code>flapMap</code> 不会在这个 <code>Optional</code> 外再多包装一层的 <code>Optional</code>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; mapper</span></span></span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,Optional&lt;U&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>orElseThrow</code> 可以在容器不包含元素时抛出异常，方法接收一个 <code>Supplier</code>, 如果要抛出的异常有无参构造方法的话，可以传入其默认构造方法的应用，例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IllegalStateException::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Optional 的 <code>orElse()</code> 和 <code>orElseGet()</code> 两个方法在包装器中没有元素的效果是一致的，都会调用并生成默认值，但是当包装其中元素存在的时候，<code>orElse()</code> 方法一定会调用，而 <code>orElseGet()</code> 方法却不会,这在默认方法是一个涉及到 I/O 时候代价会比较大。可以将某个方法 <code>getDefault()</code> 作为参数传入 <code>orElse()</code> 和 <code>orElseGet()</code> 查看方法的调用情况来判断。</p>
</li>
</ol>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 的操作可以分为中间操作（Intermediate Operation） 和 终结操作（Terminate Operation）。中间操作可以链式调用。</p>
<p>对流的操作不会影响到原数据。</p>
<h3 id="生成-Stream"><a href="#生成-Stream" class="headerlink" title="生成 Stream"></a>生成 Stream</h3><h4 id="builder-创建-Stream"><a href="#builder-创建-Stream" class="headerlink" title="builder 创建 Stream"></a>builder 创建 Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; streamBuilder =</span><br><span class="line">  Stream.&lt;String&gt;builder().add(<span class="string">"a"</span>).add(<span class="string">"b"</span>).add(<span class="string">"c"</span>).build();</span><br></pre></td></tr></table></figure>
<p>如果需要知道 Stream 元素的类型，使用上述方式，否则会生成一个元素为 Object 的 Stream。</p>
<h4 id="generate-创建-Stream"><a href="#generate-创建-Stream" class="headerlink" title="generate 创建 Stream"></a>generate 创建 Stream</h4><p>generate 接受一个 Supplier<t> 来生成元素。由于 Stream 可以是无限的，所以我们可以在 gererate 的时候指定 Stream 的大小。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; streamGenerated =</span><br><span class="line">  Stream.generate(() -&gt; <span class="string">"element"</span>).limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="iterate-创建-Stream"><a href="#iterate-创建-Stream" class="headerlink" title="iterate 创建 Stream"></a>iterate 创建 Stream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; streamIterated = Stream.iterate(<span class="number">40</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数 40 是 Stream 的第一个元素，后面的元素会由第二个参数定义的 function 逐个生成，直至达到预定的数量。</p>
<h3 id="基本类型的-Stream"><a href="#基本类型的-Stream" class="headerlink" title="基本类型的 Stream"></a>基本类型的 Stream</h3><p>由于Stream<t> 使用了泛型，但是基本类型没法作为参数（这里当然不是用基本类型的包装类，试想我们操作的数据就是基本类型的，都转换为包装类存在开销问题），支持 int, long 和 double 的 Stream。分别是 IntStream, LongStream, DoubleStream。可以缓解自动装箱带来的性能开销。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = IntStream.range(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">LongStream longStream = LongStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面第一行代码会从开始值到结束值按照步进值为1 生成 Stream。结果不包含这两个值。<br>第二行代码从开始值到结束值按照步进值为1 生成 Stream。结果包含这两个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">DoubleStream doubleStream = random.doubles(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>Java8 的 Random 也提供了大范围内的基本类型的随机数 Stream。如上述代码。会生成包含三个随机数的 double 类型的 Stream。</p>
<h3 id="String-的-Stream"><a href="#String-的-Stream" class="headerlink" title="String 的 Stream"></a>String 的 Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream streamOfChars = <span class="string">"abc"</span>.chars();</span><br></pre></td></tr></table></figure>
<p>由于 Java8 没有 CharStream，所以 char 的 Stream 用 IntStream 来代替。String 的 chars() 返回的就是 IntStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; streamOfString = Pattern.compile(<span class="string">", "</span>).splitAsStream(<span class="string">"a, b, c"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用正则匹配来将字符串切分为多个元素的 Stream。</p>
<h3 id="File-的-Stream"><a href="#File-的-Stream" class="headerlink" title="File 的 Stream"></a>File 的 Stream</h3><p>Java NIO 类允许通过 <code>lines()</code> 生成文本文件的 Stream<string>，文件的每一行都变成了 Stream 的元素。</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"C:\\file.txt"</span>);</span><br><span class="line">Stream&lt;String&gt; streamOfStrings = Files.lines(path);</span><br><span class="line">Stream&lt;String&gt; streamWithCharset = </span><br><span class="line">  Files.lines(path, Charset.forName(<span class="string">"UTF-8"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h3><p>Stream 默认支持多种聚合的方法 count(), max(), min(), sum()，这些都会计算 Stream 的某个基本类型的指标，为我们常用的计算提供了默认实现。但是如果我们想要实现自定义的一些操作如何处理呢？Java8 提供了 <code>reduce()</code> 和 <code>collect()</code> 两个方法</p>
<h4 id="1-reduce"><a href="#1-reduce" class="headerlink" title="1. reduce()"></a>1. reduce()</h4><p>这个方法有三个变体，它们之间通过方法签名和返回类型区分：</p>
<p><strong>identity</strong> 如果 Stream 是空的那么就通过它来指定累加器的初始化值<br><strong>accumulator</strong> 定义了元素累加逻辑的函数，在每次迭代中都会创建新的值，所以最终新建的值会和 Stream 元素数量一样多，但是只有最后一个是有用的，所以对性能都影响较大。<br><strong>combiner</strong> 对累加器的结果计算的函数，只有在 parallel 模式下才会进行计算</p>
<p>下面是三者的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt reduced =</span><br><span class="line">  IntStream.range(<span class="number">1</span>, <span class="number">4</span>).reduce((a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p>reduce = 6 (1 + 2 + 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int reducedTwoParams =</span><br><span class="line">  IntStream.range(1, 4).reduce(10, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p>reduce = 16 (10 + 1 + 2 + 3)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int reducedParams = Stream.of(1, 2, 3)</span><br><span class="line">  .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">     log.info(&quot;combiner was called&quot;);</span><br><span class="line">     return a + b;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>结果仍然是 16，因为不是在 paraller 模式下，所以 combiner 不会计算，要使它生效，可以改为 parallerStream,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nt reducedParallel = Arrays.asList(1, 2, 3).parallelStream()</span><br><span class="line">    .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; &#123;</span><br><span class="line">       log.info(&quot;combiner was called&quot;);</span><br><span class="line">       return a + b;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这样的结果是 36， combiner 被调用了两次。计算过程是这样的：<br>accutor 计算了三次，每次都会把 Stream 中的值加上初始值：<br>10 + 1 = 11<br>10 + 2 = 12<br>10 + 3 = 13<br>然后 combiner 计算两次<br>12 + 13 = 25;<br>25 + 11 = 36</p>
<h4 id="2-collect"><a href="#2-collect" class="headerlink" title="2. collect()"></a>2. collect()</h4><p><code>collect()</code> 主要用于将 Stream 转化为 Collection ,方便后续对 Collection 的操作和计算。</p>
<p>计算平均数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> averagePrice = productList.stream()</span><br><span class="line">  .collect(Collectors.averagingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p>计算总数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> summingPrice = productList.stream()</span><br><span class="line">  .collect(Collectors.summingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<p>averagingXX(), summingXX(), summarizingXX()  既可以用于基本类（int, long, double），也可以用于基本类的包装类(Integer, Long, Double)。</p>
<p>计算统计信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics statistics = productList.stream()</span><br><span class="line">  .collect(Collectors.summarizingInt(Product::getPrice));</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>每个 Stream 只能被使用一次，如果想重复使用结果，则需要把 Stream 转化为某些集合。</li>
<li>Stream 只能有一个 terminal operation</li>
<li>Stream Intermediate operation 是 Lazy Invocation的，只有在调用 terminal operation 的时候才会触发 intermediate operation 的调用。</li>
<li>注意最好把 skip(), filter(), distinct() 方法写在前面，这样避免不必要的方法调用</li>
<li>在生产环境中，初始化的流不消耗的话会导致内存溢出。</li>
</ol>
<h3 id="写法转换"><a href="#写法转换" class="headerlink" title="写法转换"></a>写法转换</h3><h4 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1. 遍历"></a>1. 遍历</h4><p>JDK8 之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (string.contains(<span class="string">"a"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用JDK8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isExist = list.stream().anyMatch(element -&gt; element.contains(<span class="string">"a"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="2-过滤"><a href="#2-过滤" class="headerlink" title="2. 过滤"></a>2. 过滤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = list.stream().filter(element -&gt; element.contains(<span class="string">"d"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="3-Map-flatMap"><a href="#3-Map-flatMap" class="headerlink" title="3. Map/flatMap"></a>3. Map/flatMap</h4><p>区分使用 map 和 flapMap 的场景。<br>一般情况下使用 map 或者 flapMap都是需要我们嵌套调用 get 方法来获取最深层的那个实体场景下使用的。当每层嵌套返回的都是某个具体的类，那么我们可以直接使用map;如果我们在设计类的时候或者实现 get 方法的时候，返回的不是具体的属性的类，而是这个属性的 Optional，这种情况下使用 map 就会出问题，因为相当于拿到的是嵌套了多层 Optional 的属性类，而我们实际想要的只是一个包裹了这个属性元素的Optional。</p>
<p>EG：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Car car;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    String brand;</span><br><span class="line">    Insurance insurance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> </span>&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    </span><br><span class="line">    Optional&lt;String&gt; insuranceName = Optional.ofNullable(person)</span><br><span class="line">    .map(Persion::getCar)</span><br><span class="line">    .map(Car::getInsurance)</span><br><span class="line">    .map(Insurance::getName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如我们改一下实体，从领域实体触发，一个人有没有车是不确定的，所以 Person 的 car 属性我们用 Optional<car> 来实现，同理 Car 的保险属性我们用 Optional<insurance> 来实现。</insurance></car></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Optional&lt;Car&gt; car;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    String brand;</span><br><span class="line">    Optional&lt;Insurance&gt; insurance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insurance</span> </span>&#123;</span><br><span class="line">    String name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">    </span><br><span class="line">    Optional&lt;String&gt; insuranceName = Optional.ofNullable(person)</span><br><span class="line">    .flatMap(Persion::getCar)</span><br><span class="line">    .flatMap(Car::getInsurance)</span><br><span class="line">    .map(Insurance::getName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-匹配"><a href="#4-匹配" class="headerlink" title="4. 匹配"></a>4. 匹配</h4><p>anyMatch(), allMatch(), noneMatch()</p>
<h4 id="5-Reduction"><a href="#5-Reduction" class="headerlink" title="5. Reduction"></a>5. Reduction</h4><p>数组求和</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol>
<li><p>静态方法<br> Class::methodName</p>
</li>
<li><p>实例方法</p>
<p> instance::methodName</p>
</li>
<li><p>某个特定类对象的方法</p>
<p> Type::methodName</p>
</li>
<li><p>引用构造器</p>
<p> ClassName::new</p>
</li>
</ol>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><h2 id="Lamda-Expression-Tips"><a href="#Lamda-Expression-Tips" class="headerlink" title="Lamda Expression Tips"></a>Lamda Expression Tips</h2><h3 id="1-尽可能使用标准的-Functional-Interface-比如-Java8-自带的-Functional-Consumer-Supplier-Predicate-等"><a href="#1-尽可能使用标准的-Functional-Interface-比如-Java8-自带的-Functional-Consumer-Supplier-Predicate-等" class="headerlink" title="1. 尽可能使用标准的 Functional Interface, 比如 Java8 自带的 Functional, Consumer, Supplier, Predicate 等"></a>1. 尽可能使用标准的 Functional Interface, 比如 Java8 自带的 Functional, Consumer, Supplier, Predicate 等</h3><h3 id="2-使用-FunctionalInterface-注解。这可以在我们更改一个原先的-FunctionalInterface-的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。"><a href="#2-使用-FunctionalInterface-注解。这可以在我们更改一个原先的-FunctionalInterface-的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。" class="headerlink" title="2. 使用 @FunctionalInterface 注解。这可以在我们更改一个原先的 FunctionalInterface 的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。"></a>2. 使用 <code>@FunctionalInterface</code> 注解。这可以在我们更改一个原先的 FunctionalInterface 的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。</h3><h3 id="3-在-Functional-Interface-中不要滥用-default-方法"><a href="#3-在-Functional-Interface-中不要滥用-default-方法" class="headerlink" title="3. 在 Functional Interface 中不要滥用 default 方法"></a>3. 在 Functional Interface 中不要滥用 default 方法</h3><h3 id="4-对于-Functional-Interface-来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用-lamda-表达式。"><a href="#4-对于-Functional-Interface-来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用-lamda-表达式。" class="headerlink" title="4. 对于 Functional Interface 来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用 lamda 表达式。"></a>4. 对于 Functional Interface 来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用 lamda 表达式。</h3><h3 id="5-避免使用-Functional-Interface-作为重载参数，可能会造成运行时方法引用错误。"><a href="#5-避免使用-Functional-Interface-作为重载参数，可能会造成运行时方法引用错误。" class="headerlink" title="5. 避免使用 Functional Interface 作为重载参数，可能会造成运行时方法引用错误。"></a>5. 避免使用 Functional Interface 作为重载参数，可能会造成运行时方法引用错误。</h3><p>例如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Adder</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">add</span><span class="params">(Function&lt;String, String&gt; f)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Consumer&lt;Integer&gt; f)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderImpl</span> <span class="keyword">implements</span> <span class="title">Adder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">add</span><span class="params">(Function&lt;String, String&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.apply(<span class="string">"Something "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Consumer&lt;Integer&gt; f)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String r = adderImpl.add(a -&gt; a + <span class="string">" from lambda"</span>);</span><br></pre></td></tr></table></figure>
<p>会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reference to add is ambiguous both method </span><br><span class="line">add(java.util.function.Function&lt;java.lang.String,java.lang.String&gt;) </span><br><span class="line">in fiandlambdas.AdderImpl and method </span><br><span class="line">add(java.util.function.Consumer&lt;java.lang.Integer&gt;) </span><br><span class="line">in fiandlambdas.AdderImpl match</span><br></pre></td></tr></table></figure>
<p>对于这种情况我们通常有两种解决方案：</p>
<ol>
<li>修改两个方法的名字不一致即可</li>
<li><p>调用时候进行类型转换，如下面的代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String r = Adder.add((Function) a -&gt; a + <span class="string">" from lambda"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-不要把-Lamda-Expression-当成内部类"><a href="#6-不要把-Lamda-Expression-当成内部类" class="headerlink" title="6. 不要把 Lamda Expression 当成内部类"></a>6. 不要把 Lamda Expression 当成内部类</h3><p>Lamda Expression 和 内部类的最大区别在于作用域（Scope）不同。</p>
<p>内部类会创建一个属于这个内部类的作用域。在这个作用域内可以初始化一个和所在类或者方法内同名的本地变量，也可以使用 this 来指代当前的内部类。</p>
<p>Lamda Expression 作用于当前的闭包作用域，在 Lamda Expression 的代码块内不能修改闭包内的变量，而在 Lamda Expression 方法体内的 this 指代的是所在闭包。</p>
<p>如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFoo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value = <span class="string">"Enclosing scope value"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">scopeExperiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Foo fooIC = <span class="keyword">new</span> Foo() &#123;</span><br><span class="line">            String value = <span class="string">"Inner class value"</span>;</span><br><span class="line">     </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String resultIC = fooIC.method(<span class="string">""</span>);</span><br><span class="line">     </span><br><span class="line">        Foo fooLambda = parameter -&gt; &#123;</span><br><span class="line">            String value = <span class="string">"Lambda value"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        String resultLambda = fooLambda.method(<span class="string">""</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Results: resultIC = "</span> + resultIC + </span><br><span class="line">          <span class="string">", resultLambda = "</span> + resultLambda;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后打印结果为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Results: resultIC = Inner class value, resultLambda = Enclosing scope value</span><br></pre></td></tr></table></figure>
<p>所以在 IC 内使用 <code>this.value</code> 会使用内部类的局部变量，而使用 Lamda 的 <code>this.value</code> 则接触到的是 UseFoo 这个类实例的 value 变量，而不是定义在 Lamda 内部的 value。</p>
<h3 id="7-保持-Lamda-Expression-尽可能短和易懂"><a href="#7-保持-Lamda-Expression-尽可能短和易懂" class="headerlink" title="7. 保持 Lamda Expression 尽可能短和易懂"></a>7. 保持 Lamda Expression 尽可能短和易懂</h3><p>Lamda 的方法体尽可能一行或者更短，而不是大块的代码块。因为 Lamda 首先应该是个<strong>表达式</strong>，应该尽可能的描述所能提供的功能。有下面几种实现方式：</p>
<h4 id="7-1-避免在-Lamda-内使用代码块"><a href="#7-1-避免在-Lamda-内使用代码块" class="headerlink" title="7.1 避免在 Lamda 内使用代码块"></a>7.1 避免在 Lamda 内使用代码块</h4><p>Bad Impl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = parameter -&gt; &#123; String result = <span class="string">"Something "</span> + parameter; </span><br><span class="line">    <span class="comment">//many lines of code </span></span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Good Impl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Foo foo = parameter -&gt; buildString(parameter);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildString</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line">    String result = <span class="string">"Something "</span> + parameter;</span><br><span class="line">    <span class="comment">//many lines of code</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也不能死板教条，两三行还是可以的。为了两三行代码抽一个方法出来不值得。</p>
<h4 id="7-2-避免定义参数类型"><a href="#7-2-避免定义参数类型" class="headerlink" title="7.2 避免定义参数类型"></a>7.2 避免定义参数类型</h4><p>大多数的编译器可以通过类型引用推断参数类型的，所以在形参加上类型是可选的，所以可以忽略掉。</p>
<p>Bad Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String a, String b) -&gt; a.toLowerCase() + b.toLowerCase();</span><br></pre></td></tr></table></figure>
<p>Good Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a, b) -&gt; a.toLowerCase() + b.toLowerCase();</span><br></pre></td></tr></table></figure>
<h4 id="7-3-避免在单个参数时使用括号"><a href="#7-3-避免在单个参数时使用括号" class="headerlink" title="7.3 避免在单个参数时使用括号"></a>7.3 避免在单个参数时使用括号</h4><p>只有在无参数或者多个参数的时候才要求使用括号。所以只有一个参数的情况下，不适用括号是可以的。</p>
<h4 id="7-4-避免使用-return-语句和大括号"><a href="#7-4-避免使用-return-语句和大括号" class="headerlink" title="7.4 避免使用 return 语句和大括号"></a>7.4 避免使用 return 语句和大括号</h4><p>Bad Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; &#123;return a.toLowerCase()&#125;;</span><br></pre></td></tr></table></figure>
<p>Good Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; a.toLowerCase();</span><br></pre></td></tr></table></figure>
<h4 id="7-5-使用方法引用"><a href="#7-5-使用方法引用" class="headerlink" title="7.5 使用方法引用"></a>7.5 使用方法引用</h4><p>主要目的在于增加可读性</p>
<p>Bad Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; a.toLowerCase();</span><br></pre></td></tr></table></figure>
<p>Good Impl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::toLowerCase;</span><br></pre></td></tr></table></figure>
<h3 id="8-使用-“effective-final”-变量"><a href="#8-使用-“effective-final”-变量" class="headerlink" title="8 使用 “effective final” 变量"></a>8 使用 “effective final” 变量</h3><p>在 Lamda 中访问 non-final 的变量会报编译错误，但是这并不意为这你需要把每个变量都标记为 final 的。<br>如果某个变量只被赋值一次，那么编译器就可以把这个变量看做是 final 的。在 Lamda 内使用这种变量是安全的，因为编译器会控制这些变量的状态，并在任何尝试改变这些变量发生时触发<strong>编译期</strong>的错误（是否意味着我们直接操作 class 文件的话可以绕过这个限制？）。下面的代码不能编译通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String localVariable = <span class="string">"Local"</span>;</span><br><span class="line">    Foo foo = parameter -&gt; &#123;</span><br><span class="line">        String localVariable = parameter;</span><br><span class="line">        <span class="keyword">return</span> localVariable;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误提示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Variable &apos;localVariable&apos; is already defined in the scope.</span><br></pre></td></tr></table></figure>
<h3 id="9-保护变量突变"><a href="#9-保护变量突变" class="headerlink" title="9 保护变量突变"></a>9 保护变量突变</h3><p>使用 Lamda 的一个目的是并行计算，这也就意味着在线程安全方面是很安全的。</p>
<p>上面第 8 点说的 effective final 变量对线程安全是有帮助的，但是也不能覆盖全部的情况。Lamda 不能在闭包范围内更新一个对象的属性，但是对于突变的对象变量这种情况而言，在 Lamda 内的 state 是可以更新的。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] total = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">Runnable r = () -&gt; total[<span class="number">0</span>]++;</span><br><span class="line">r.run();</span><br></pre></td></tr></table></figure>
<p>这段代码是合法的，因为所有变量都是等效 final 的，但是在执行完 Lamda 之后对象的状态和执行之前一样吗？答案是否定的。<br>这个例子提醒我们避免可能导致期望值外的突变的代码。</p>
<p>参考资料</p>
<ol>
<li><a href="https://www.baeldung.com/java-optional" target="_blank" rel="noopener">https://www.baeldung.com/java-optional</a>  Optional 第7点摘自这篇文章</li>
<li><a href="https://github.com/eugenp/tutorials/tree/master/core-java-8" target="_blank" rel="noopener">https://github.com/eugenp/tutorials/tree/master/core-java-8</a> JDK8 的一些介绍</li>
<li><a href="https://www.baeldung.com/java-filter-stream-of-optional" target="_blank" rel="noopener">https://www.baeldung.com/java-filter-stream-of-optional</a></li>
<li><a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">暂时访问不了的博客</a></li>
<li><a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">暂时访问不了的博客</a></li>
<li><a href="https://www.baeldung.com/java-fork-join" target="_blank" rel="noopener">https://www.baeldung.com/java-fork-join</a></li>
<li><a href="https://www.baeldung.com/java-executor-service-tutorial" target="_blank" rel="noopener">https://www.baeldung.com/java-executor-service-tutorial</a></li>
<li><a href="https://www.baeldung.com/java-8-streams" target="_blank" rel="noopener">https://www.baeldung.com/java-8-streams</a> covered</li>
<li><a href="https://www.baeldung.com/java-8-lambda-expressions-tips" target="_blank" rel="noopener">Lambda Expressions and Functional Interfaces: Tips and Best Practices</a> covered</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jave8/" rel="tag"># jave8</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/20/正式开始blog记录/" rel="next" title="正式开始blog记录">
                <i class="fa fa-chevron-left"></i> 正式开始blog记录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/31/2018有感/" rel="prev" title="2018有感">
                2018有感 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="zomeone" />
            
              <p class="site-author-name" itemprop="name">zomeone</p>
              <p class="site-description motion-element" itemprop="description">程序界的小学生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK8-新特性-使用注意事项"><span class="nav-number">1.</span> <span class="nav-text">JDK8 新特性 使用注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional"><span class="nav-number">1.1.</span> <span class="nav-text">Optional</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">1.2.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生成-Stream"><span class="nav-number">1.2.1.</span> <span class="nav-text">生成 Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#builder-创建-Stream"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">builder 创建 Stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#generate-创建-Stream"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">generate 创建 Stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iterate-创建-Stream"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">iterate 创建 Stream</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型的-Stream"><span class="nav-number">1.2.2.</span> <span class="nav-text">基本类型的 Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-的-Stream"><span class="nav-number">1.2.3.</span> <span class="nav-text">String 的 Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-的-Stream"><span class="nav-number">1.2.4.</span> <span class="nav-text">File 的 Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reduction"><span class="nav-number">1.2.5.</span> <span class="nav-text">Reduction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-reduce"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">1. reduce()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-collect"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2. collect()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">1.2.6.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写法转换"><span class="nav-number">1.2.7.</span> <span class="nav-text">写法转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-遍历"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">1. 遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-过滤"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">2. 过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map-flatMap"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">3. Map/flatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-匹配"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">4. 匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Reduction"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">5. Reduction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法引用"><span class="nav-number">1.3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Interface"><span class="nav-number">1.4.</span> <span class="nav-text">Interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lamda-Expression-Tips"><span class="nav-number">1.5.</span> <span class="nav-text">Lamda Expression Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-尽可能使用标准的-Functional-Interface-比如-Java8-自带的-Functional-Consumer-Supplier-Predicate-等"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 尽可能使用标准的 Functional Interface, 比如 Java8 自带的 Functional, Consumer, Supplier, Predicate 等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-使用-FunctionalInterface-注解。这可以在我们更改一个原先的-FunctionalInterface-的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 使用 @FunctionalInterface 注解。这可以在我们更改一个原先的 FunctionalInterface 的结构（尤其是增加一个抽象方法）的时候，编译报错，防止我们意外更改。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-在-Functional-Interface-中不要滥用-default-方法"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. 在 Functional Interface 中不要滥用 default 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-对于-Functional-Interface-来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用-lamda-表达式。"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. 对于 Functional Interface 来说，编译器允许我们实例化一个接口实例（匿名内部类？），这样写代码是很笨重的，最好用 lamda 表达式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-避免使用-Functional-Interface-作为重载参数，可能会造成运行时方法引用错误。"><span class="nav-number">1.5.5.</span> <span class="nav-text">5. 避免使用 Functional Interface 作为重载参数，可能会造成运行时方法引用错误。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-不要把-Lamda-Expression-当成内部类"><span class="nav-number">1.5.6.</span> <span class="nav-text">6. 不要把 Lamda Expression 当成内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-保持-Lamda-Expression-尽可能短和易懂"><span class="nav-number">1.5.7.</span> <span class="nav-text">7. 保持 Lamda Expression 尽可能短和易懂</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-避免在-Lamda-内使用代码块"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">7.1 避免在 Lamda 内使用代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-避免定义参数类型"><span class="nav-number">1.5.7.2.</span> <span class="nav-text">7.2 避免定义参数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-避免在单个参数时使用括号"><span class="nav-number">1.5.7.3.</span> <span class="nav-text">7.3 避免在单个参数时使用括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-避免使用-return-语句和大括号"><span class="nav-number">1.5.7.4.</span> <span class="nav-text">7.4 避免使用 return 语句和大括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-使用方法引用"><span class="nav-number">1.5.7.5.</span> <span class="nav-text">7.5 使用方法引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-使用-“effective-final”-变量"><span class="nav-number">1.5.8.</span> <span class="nav-text">8 使用 “effective final” 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-保护变量突变"><span class="nav-number">1.5.9.</span> <span class="nav-text">9 保护变量突变</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zomeone</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
